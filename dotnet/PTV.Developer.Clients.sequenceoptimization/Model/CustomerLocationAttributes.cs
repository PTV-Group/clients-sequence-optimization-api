/*
 * Sequence Optimization
 *
 * With the Sequence Optimization service you can find the best route for your transports.
 *
 * The version of the OpenAPI document: 1.5
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.sequenceoptimization.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.sequenceoptimization.Model
{
    /// <summary>
    /// Attributes for a location of type CUSTOMER.
    /// </summary>
    [DataContract(Name = "CustomerLocationAttributes")]
    public partial class CustomerLocationAttributes : IEquatable<CustomerLocationAttributes>, IValidatableObject
    {

        /// <summary>
        /// Gets or Sets PositionInRoute
        /// </summary>
        [DataMember(Name = "positionInRoute", EmitDefaultValue = true)]
        public PositionInRoute? PositionInRoute { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="CustomerLocationAttributes" /> class.
        /// </summary>
        /// <param name="serviceTimePerTransportStop">The service time [s] that is required each time this location is visited in order to pick goods up or to deliver them. The location-dependent service time represents, for example, the time to enter the premises or to register at a customer. Besides a location-dependent service time, the user may specify an additional transport-dependent service time at the transports. (default to 0).</param>
        /// <param name="positionInRoute">positionInRoute.</param>
        /// <param name="routeSectionNumber">If routeSectionNumber is specified, a stop at this customer location will be visited after stops at customer locations with specified lower routeSectionNumber and before stops at customer locations with specified higher routeSectionNumber. Consequently, the route section numbers of stops at customer locations must be non-decreasing.   If specified, positionInRoute must not be set for the same location.  See [here](./Concepts/Route%20sections%20and%20Position%20in%20route.htm) for more information..</param>
        public CustomerLocationAttributes(int serviceTimePerTransportStop = 0, PositionInRoute? positionInRoute = default(PositionInRoute?), int? routeSectionNumber = default(int?))
        {
            this.ServiceTimePerTransportStop = serviceTimePerTransportStop;
            this.PositionInRoute = positionInRoute;
            this.RouteSectionNumber = routeSectionNumber;
        }

        /// <summary>
        /// The service time [s] that is required each time this location is visited in order to pick goods up or to deliver them. The location-dependent service time represents, for example, the time to enter the premises or to register at a customer. Besides a location-dependent service time, the user may specify an additional transport-dependent service time at the transports.
        /// </summary>
        /// <value>The service time [s] that is required each time this location is visited in order to pick goods up or to deliver them. The location-dependent service time represents, for example, the time to enter the premises or to register at a customer. Besides a location-dependent service time, the user may specify an additional transport-dependent service time at the transports.</value>
        [DataMember(Name = "serviceTimePerTransportStop", EmitDefaultValue = false)]
        public int ServiceTimePerTransportStop { get; set; }

        /// <summary>
        /// If routeSectionNumber is specified, a stop at this customer location will be visited after stops at customer locations with specified lower routeSectionNumber and before stops at customer locations with specified higher routeSectionNumber. Consequently, the route section numbers of stops at customer locations must be non-decreasing.   If specified, positionInRoute must not be set for the same location.  See [here](./Concepts/Route%20sections%20and%20Position%20in%20route.htm) for more information.
        /// </summary>
        /// <value>If routeSectionNumber is specified, a stop at this customer location will be visited after stops at customer locations with specified lower routeSectionNumber and before stops at customer locations with specified higher routeSectionNumber. Consequently, the route section numbers of stops at customer locations must be non-decreasing.   If specified, positionInRoute must not be set for the same location.  See [here](./Concepts/Route%20sections%20and%20Position%20in%20route.htm) for more information.</value>
        [DataMember(Name = "routeSectionNumber", EmitDefaultValue = true)]
        public int? RouteSectionNumber { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CustomerLocationAttributes {\n");
            sb.Append("  ServiceTimePerTransportStop: ").Append(ServiceTimePerTransportStop).Append("\n");
            sb.Append("  PositionInRoute: ").Append(PositionInRoute).Append("\n");
            sb.Append("  RouteSectionNumber: ").Append(RouteSectionNumber).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CustomerLocationAttributes);
        }

        /// <summary>
        /// Returns true if CustomerLocationAttributes instances are equal
        /// </summary>
        /// <param name="input">Instance of CustomerLocationAttributes to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CustomerLocationAttributes input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.ServiceTimePerTransportStop == input.ServiceTimePerTransportStop ||
                    this.ServiceTimePerTransportStop.Equals(input.ServiceTimePerTransportStop)
                ) && 
                (
                    this.PositionInRoute == input.PositionInRoute ||
                    this.PositionInRoute.Equals(input.PositionInRoute)
                ) && 
                (
                    this.RouteSectionNumber == input.RouteSectionNumber ||
                    (this.RouteSectionNumber != null &&
                    this.RouteSectionNumber.Equals(input.RouteSectionNumber))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.ServiceTimePerTransportStop.GetHashCode();
                hashCode = (hashCode * 59) + this.PositionInRoute.GetHashCode();
                if (this.RouteSectionNumber != null)
                {
                    hashCode = (hashCode * 59) + this.RouteSectionNumber.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            // ServiceTimePerTransportStop (int) minimum
            if (this.ServiceTimePerTransportStop < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ServiceTimePerTransportStop, must be a value greater than or equal to 0.", new [] { "ServiceTimePerTransportStop" });
            }

            // RouteSectionNumber (int?) minimum
            if (this.RouteSectionNumber < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RouteSectionNumber, must be a value greater than or equal to 1.", new [] { "RouteSectionNumber" });
            }

            yield break;
        }
    }

}
